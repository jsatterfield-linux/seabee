<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SeaBee: /github/workspace/bpf/src/seabee/seabee.bpf.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SeaBee
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_7e46271e71bceff8cce0f28c9873f6df.html">bpf</a></li><li class="navelem"><a class="el" href="dir_c75ad9c7aab4ddc9105ba1f9fe057a73.html">src</a></li><li class="navelem"><a class="el" href="dir_744d7f4b771e49251f50eeb95e08ad38.html">seabee</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">seabee.bpf.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;vmlinux.h&quot;</code><br />
<code>#include &lt;bpf/bpf_helpers.h&gt;</code><br />
<code>#include &lt;bpf/bpf_tracing.h&gt;</code><br />
<code>#include &lt;bpf/bpf_core_read.h&gt;</code><br />
<code>#include &lt;linux/version.h&gt;</code><br />
<code>#include &quot;<a class="el" href="logging_8h_source.html">logging.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="logging__types_8h_source.html">logging_types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="seabee__log_8h_source.html">seabee_log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="seabee__maps_8h_source.html">seabee_maps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="seabee__utils_8h_source.html">seabee_utils.h</a>&quot;</code><br />
<code>#include &quot;shared_rust_types.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for seabee.bpf.c:</div>
<div class="dyncontent">
<div class="center"><img src="seabee_8bpf_8c__incl.png" border="0" usemap="#a_2github_2workspace_2bpf_2src_2seabee_2seabee_8bpf_8c" alt=""/></div>
<map name="a_2github_2workspace_2bpf_2src_2seabee_2seabee_8bpf_8c" id="a_2github_2workspace_2bpf_2src_2seabee_2seabee_8bpf_8c">
<area shape="rect" title=" " alt="" coords="445,5,611,46"/>
<area shape="rect" title=" " alt="" coords="671,315,747,341"/>
<area shape="poly" title=" " alt="" coords="600,44,650,64,697,92,741,125,773,155,797,190,818,240,822,255,818,268,794,295,763,313,760,308,790,291,813,266,817,254,813,242,792,193,769,158,738,129,694,96,647,69,598,49"/>
<area shape="rect" title=" " alt="" coords="804,315,924,341"/>
<area shape="poly" title=" " alt="" coords="612,43,673,63,732,92,776,122,805,153,826,191,846,240,862,299,857,300,841,242,821,193,801,156,772,126,729,96,671,68,611,48"/>
<area shape="rect" title=" " alt="" coords="50,94,168,120"/>
<area shape="poly" title=" " alt="" coords="445,45,184,94,183,89,444,40"/>
<area shape="rect" title=" " alt="" coords="192,94,327,120"/>
<area shape="poly" title=" " alt="" coords="462,49,316,92,315,87,460,44"/>
<area shape="rect" title=" " alt="" coords="352,94,455,120"/>
<area shape="poly" title=" " alt="" coords="499,49,437,88,434,83,496,44"/>
<area shape="rect" href="logging_8h.html" title=" " alt="" coords="494,241,567,267"/>
<area shape="poly" title=" " alt="" coords="555,45,575,66,592,93,596,112,597,131,588,169,571,203,552,231,548,228,567,200,583,167,592,131,591,113,587,95,571,69,551,48"/>
<area shape="rect" href="logging__types_8h.html" title=" " alt="" coords="333,315,443,341"/>
<area shape="poly" title=" " alt="" coords="444,35,326,44,195,58,85,75,48,85,28,96,15,115,9,134,9,151,16,168,28,185,44,200,89,229,144,255,204,277,318,309,317,314,203,282,142,260,86,234,41,204,24,188,11,171,4,152,4,133,10,113,25,92,46,80,83,70,194,52,325,39,444,30"/>
<area shape="rect" href="shared__rust__types_8h_source.html" title=" " alt="" coords="467,315,604,341"/>
<area shape="poly" title=" " alt="" coords="444,28,335,31,214,40,157,49,107,61,67,76,40,96,34,109,35,122,44,136,60,151,111,182,178,212,336,268,474,308,473,313,334,273,176,217,108,187,57,155,40,139,30,124,29,108,36,92,64,72,105,56,156,44,213,35,335,26,444,23"/>
<area shape="rect" href="seabee__log_8h.html" title=" " alt="" coords="479,94,576,120"/>
<area shape="poly" title=" " alt="" coords="530,46,530,78,525,78,525,46"/>
<area shape="rect" href="seabee__utils_8h.html" title=" " alt="" coords="613,168,717,193"/>
<area shape="poly" title=" " alt="" coords="573,44,606,65,635,92,652,122,662,152,657,154,648,124,631,96,602,69,570,49"/>
<area shape="rect" href="seabee__maps_8h.html" title=" " alt="" coords="692,241,804,267"/>
<area shape="poly" title=" " alt="" coords="580,44,620,64,662,91,701,125,731,166,743,197,748,226,743,227,738,198,727,169,697,128,659,95,617,68,578,49"/>
<area shape="poly" title=" " alt="" coords="562,265,666,306,664,311,560,270"/>
<area shape="poly" title=" " alt="" coords="567,261,793,309,792,314,566,266"/>
<area shape="poly" title=" " alt="" coords="507,270,427,310,425,305,505,265"/>
<area shape="poly" title=" " alt="" coords="534,267,536,299,531,300,529,267"/>
<area shape="rect" href="constants_8h.html" title=" " alt="" coords="417,389,505,414"/>
<area shape="poly" title=" " alt="" coords="402,339,440,376,436,380,398,343"/>
<area shape="poly" title=" " alt="" coords="525,343,486,380,483,376,521,339"/>
<area shape="poly" title=" " alt="" coords="531,120,533,226,527,226,525,120"/>
<area shape="poly" title=" " alt="" coords="522,121,505,148,489,184,480,225,480,246,485,266,496,286,511,303,507,306,492,289,480,268,475,247,474,225,484,183,501,145,517,119"/>
<area shape="poly" title=" " alt="" coords="552,118,629,158,627,162,550,123"/>
<area shape="poly" title=" " alt="" coords="669,193,673,227,682,266,697,300,692,302,677,268,668,228,663,194"/>
<area shape="poly" title=" " alt="" coords="719,191,769,209,795,223,818,239,841,268,857,299,852,302,837,271,814,243,792,227,767,214,717,196"/>
<area shape="poly" title=" " alt="" coords="644,196,568,236,565,231,641,192"/>
<area shape="poly" title=" " alt="" coords="613,195,549,214,484,244,443,274,410,306,406,302,439,270,481,239,548,209,612,190"/>
<area shape="poly" title=" " alt="" coords="657,195,558,305,554,302,653,192"/>
<area shape="poly" title=" " alt="" coords="681,192,724,229,721,233,677,196"/>
<area shape="poly" title=" " alt="" coords="744,268,725,302,721,300,739,266"/>
<area shape="poly" title=" " alt="" coords="769,265,833,304,830,309,766,270"/>
<area shape="poly" title=" " alt="" coords="713,270,587,312,585,307,711,265"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpath__to__pol__id.html">path_to_pol_id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpath__storage.html">path_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">storage path buffers which cannot fit on ebpf stack per cpu is important to prevent concurrency issues  <a href="structpath__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae003a38311b8eb87254113b1c57a38f0" id="r_ae003a38311b8eb87254113b1c57a38f0"><td class="memItemLeft" align="right" valign="top"><a id="ae003a38311b8eb87254113b1c57a38f0" name="ae003a38311b8eb87254113b1c57a38f0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FMODE_WRITE</b>&#160;&#160;&#160;(1 &lt;&lt; 1)</td></tr>
<tr class="separator:ae003a38311b8eb87254113b1c57a38f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a29a8315efd07a8542742e0c0cc389e0a" id="r_a29a8315efd07a8542742e0c0cc389e0a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29a8315efd07a8542742e0c0cc389e0a">seabee_bpf_map</a> (struct bpf_map *map, fmode_t fmode, int ret)</td></tr>
<tr class="memdesc:a29a8315efd07a8542742e0c0cc389e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks manipulation a protected map.  <br /></td></tr>
<tr class="separator:a29a8315efd07a8542742e0c0cc389e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0513d1676e6013f62974623e1523da" id="r_a5e0513d1676e6013f62974623e1523da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e0513d1676e6013f62974623e1523da">seabee_locked_down</a> (enum lockdown_reason what,)</td></tr>
<tr class="memdesc:a5e0513d1676e6013f62974623e1523da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the use of the bpf_write_user() helper.  <br /></td></tr>
<tr class="separator:a5e0513d1676e6013f62974623e1523da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0493f708b0f0ddf94b055afa38347f9" id="r_ae0493f708b0f0ddf94b055afa38347f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0493f708b0f0ddf94b055afa38347f9">seabee_task_kill</a> (struct task_struct *p, struct kernel_siginfo *info, int sig, const struct cred *cred, int ret)</td></tr>
<tr class="memdesc:ae0493f708b0f0ddf94b055afa38347f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block unwanted signals to the seabee userspace process.  <br /></td></tr>
<tr class="separator:ae0493f708b0f0ddf94b055afa38347f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17afaf237b1083b2eb37cb8607c6bb3f" id="r_a17afaf237b1083b2eb37cb8607c6bb3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17afaf237b1083b2eb37cb8607c6bb3f">seabee_file_open</a> (struct file *file,)</td></tr>
<tr class="memdesc:a17afaf237b1083b2eb37cb8607c6bb3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">make protected files read-only.  <br /></td></tr>
<tr class="separator:a17afaf237b1083b2eb37cb8607c6bb3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7949bcbdd6820449daf5836350c9695e" id="r_a7949bcbdd6820449daf5836350c9695e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7949bcbdd6820449daf5836350c9695e">seabee_inode_unlink</a> (struct inode *dir, struct dentry *dentry, int ret)</td></tr>
<tr class="memdesc:a7949bcbdd6820449daf5836350c9695e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevents unlinking/removing the protected pins.  <br /></td></tr>
<tr class="separator:a7949bcbdd6820449daf5836350c9695e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b9df20c0568dc8c64f602f63e14856" id="r_a81b9df20c0568dc8c64f602f63e14856"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81b9df20c0568dc8c64f602f63e14856">seabee_sb_umount</a> (struct vfsmount *mnt, int flags, int ret)</td></tr>
<tr class="memdesc:a81b9df20c0568dc8c64f602f63e14856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevent unmounting the BPF filesystem.  <br /></td></tr>
<tr class="separator:a81b9df20c0568dc8c64f602f63e14856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4c0b3cece29f53f28020c11e5310fc" id="r_afe4c0b3cece29f53f28020c11e5310fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe4c0b3cece29f53f28020c11e5310fc">seabee_kernel_module_request</a> (char *kmod_name,)</td></tr>
<tr class="memdesc:afe4c0b3cece29f53f28020c11e5310fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prevent a kernel module from being automatically loaded by the kernel.  <br /></td></tr>
<tr class="separator:afe4c0b3cece29f53f28020c11e5310fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485e0bd9e20eae669ea092248bf26ecf" id="r_a485e0bd9e20eae669ea092248bf26ecf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a485e0bd9e20eae669ea092248bf26ecf">seabee_kernel_read_file</a> (struct file *file, enum kernel_read_file_id id, bool contents)</td></tr>
<tr class="memdesc:a485e0bd9e20eae669ea092248bf26ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the loading of a kernel module via a file handle.  <br /></td></tr>
<tr class="separator:a485e0bd9e20eae669ea092248bf26ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256b85baf8c830a5ed40975c94943bdd" id="r_a256b85baf8c830a5ed40975c94943bdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a256b85baf8c830a5ed40975c94943bdd">seabee_kernel_load_data</a> (enum kernel_load_data_id id, bool contents)</td></tr>
<tr class="memdesc:a256b85baf8c830a5ed40975c94943bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the loading of a kernel module via a data blob.  <br /></td></tr>
<tr class="separator:a256b85baf8c830a5ed40975c94943bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28ea14e7ad0112bd28ca673105daf7e" id="r_ad28ea14e7ad0112bd28ca673105daf7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad28ea14e7ad0112bd28ca673105daf7e">seabee_ptrace_access_check</a> (struct task_struct *child, unsigned int mode, int ret)</td></tr>
<tr class="memdesc:ad28ea14e7ad0112bd28ca673105daf7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks attempts to trace the seabee userspace process.  <br /></td></tr>
<tr class="separator:ad28ea14e7ad0112bd28ca673105daf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896edf055e965814fe057c78e6206c59" id="r_a896edf055e965814fe057c78e6206c59"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a896edf055e965814fe057c78e6206c59">seabee_task_alloc</a> (struct task_struct *task, unsigned long clone_flags, int ret)</td></tr>
<tr class="memdesc:a896edf055e965814fe057c78e6206c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks attempts to fork() the seabee process.  <br /></td></tr>
<tr class="separator:a896edf055e965814fe057c78e6206c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b867df13b7a473049f1a0f3b7a2033" id="r_a85b867df13b7a473049f1a0f3b7a2033"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85b867df13b7a473049f1a0f3b7a2033">seabee_label_sock</a> (struct socket *sock, struct sockaddr *address, int addrlen)</td></tr>
<tr class="memdesc:a85b867df13b7a473049f1a0f3b7a2033"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to label a socket on creation.  <br /></td></tr>
<tr class="separator:a85b867df13b7a473049f1a0f3b7a2033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7862e20a4d187c60d970fdf02fd84c55" id="r_a7862e20a4d187c60d970fdf02fd84c55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7862e20a4d187c60d970fdf02fd84c55">seabeectl_auth</a> (struct sock *sock, struct sock *other, struct sock *newsk)</td></tr>
<tr class="memdesc:a7862e20a4d187c60d970fdf02fd84c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if a process is allowed to connect to a socket.  <br /></td></tr>
<tr class="separator:a7862e20a4d187c60d970fdf02fd84c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9230263f1e385048936352e3412647bf" id="r_a9230263f1e385048936352e3412647bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9230263f1e385048936352e3412647bf">seabee_label_process</a> (struct linux_binprm *bprm, int ret)</td></tr>
<tr class="memdesc:a9230263f1e385048936352e3412647bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Label a process when it starts.  <br /></td></tr>
<tr class="separator:a9230263f1e385048936352e3412647bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd6be4f79d69edaf1cc0ff88f15503f" id="r_a0bd6be4f79d69edaf1cc0ff88f15503f"><td class="memItemLeft" align="right" valign="top"><a id="a0bd6be4f79d69edaf1cc0ff88f15503f" name="a0bd6be4f79d69edaf1cc0ff88f15503f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>seabee_label_child_process</b> (struct task_struct *child_task, unsigned long clone_flags)</td></tr>
<tr class="memdesc:a0bd6be4f79d69edaf1cc0ff88f15503f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Label a child process with same policy id as its parent. <br /></td></tr>
<tr class="separator:a0bd6be4f79d69edaf1cc0ff88f15503f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac336eff3508f5fe3d2484963c1ea9c13" id="r_ac336eff3508f5fe3d2484963c1ea9c13"><td class="memItemLeft" align="right" valign="top"><a id="ac336eff3508f5fe3d2484963c1ea9c13" name="ac336eff3508f5fe3d2484963c1ea9c13"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>seabee_label_map</b> (struct bpf_map *map, union bpf_attr *attr, struct bpf_token *token, int ret)</td></tr>
<tr class="memdesc:ac336eff3508f5fe3d2484963c1ea9c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Label an eBPF map on creation using the same label as the process that created it. <br /></td></tr>
<tr class="separator:ac336eff3508f5fe3d2484963c1ea9c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18317988a2eda364be8a3107e08d6c6c" id="r_a18317988a2eda364be8a3107e08d6c6c"><td class="memItemLeft" align="right" valign="top"><a id="a18317988a2eda364be8a3107e08d6c6c" name="a18317988a2eda364be8a3107e08d6c6c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>seabee_unlabel_map</b> (struct bpf_map *map, int ret)</td></tr>
<tr class="memdesc:a18317988a2eda364be8a3107e08d6c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlabel an eBPF map when it is freed. <br /></td></tr>
<tr class="separator:a18317988a2eda364be8a3107e08d6c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b17c95c781662391327c1dd0962cc3" id="r_a34b17c95c781662391327c1dd0962cc3"><td class="memItemLeft" align="right" valign="top"><a id="a34b17c95c781662391327c1dd0962cc3" name="a34b17c95c781662391327c1dd0962cc3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>seabee_label_pin</b> (int cmd, union bpf_attr *attr, unsigned int size, int ret)</td></tr>
<tr class="memdesc:a34b17c95c781662391327c1dd0962cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Label an eBPF pin when it is created, using the same label as the process that created it. <br /></td></tr>
<tr class="separator:a34b17c95c781662391327c1dd0962cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a094e2d5d611f0260d7e08d3e03c4dafd" id="r_a094e2d5d611f0260d7e08d3e03c4dafd"><td class="memItemLeft" align="right" valign="top"><a id="a094e2d5d611f0260d7e08d3e03c4dafd" name="a094e2d5d611f0260d7e08d3e03c4dafd"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>LICENSE</b> [] = &quot;GPL&quot;</td></tr>
<tr class="memdesc:a094e2d5d611f0260d7e08d3e03c4dafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">License of the BPF program. <br /></td></tr>
<tr class="separator:a094e2d5d611f0260d7e08d3e03c4dafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5b3870f32ed99cf58fe41b09d15181" id="r_a9e5b3870f32ed99cf58fe41b09d15181"><td class="memItemLeft" align="right" valign="top">u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e5b3870f32ed99cf58fe41b09d15181">log_level</a></td></tr>
<tr class="memdesc:a9e5b3870f32ed99cf58fe41b09d15181"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level of the logs to filter out.  <br /></td></tr>
<tr class="separator:a9e5b3870f32ed99cf58fe41b09d15181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6260542ad29c93bcc8f09d6a11f4e587" id="r_a6260542ad29c93bcc8f09d6a11f4e587"><td class="memItemLeft" align="right" valign="top"><a id="a6260542ad29c93bcc8f09d6a11f4e587" name="a6260542ad29c93bcc8f09d6a11f4e587"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><b>kmod_modification</b></td></tr>
<tr class="memdesc:a6260542ad29c93bcc8f09d6a11f4e587"><td class="mdescLeft">&#160;</td><td class="mdescRight">The level of access for kernel modules. <br /></td></tr>
<tr class="separator:a6260542ad29c93bcc8f09d6a11f4e587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae208ec30e868b98262cf15e4f4f88f9e" id="r_ae208ec30e868b98262cf15e4f4f88f9e"><td class="memItemLeft" align="right" valign="top"><a id="ae208ec30e868b98262cf15e4f4f88f9e" name="ae208ec30e868b98262cf15e4f4f88f9e"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><b>my_pid</b></td></tr>
<tr class="memdesc:ae208ec30e868b98262cf15e4f4f88f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The process id of the userspace that loads these programs. <br /></td></tr>
<tr class="separator:ae208ec30e868b98262cf15e4f4f88f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa241be73ffbea4de2071fd4eb6a2dd06" id="r_aa241be73ffbea4de2071fd4eb6a2dd06"><td class="memItemLeft" align="right" valign="top"><a id="aa241be73ffbea4de2071fd4eb6a2dd06" name="aa241be73ffbea4de2071fd4eb6a2dd06"></a>
u64&#160;</td><td class="memItemRight" valign="bottom"><b>sigmask</b></td></tr>
<tr class="memdesc:aa241be73ffbea4de2071fd4eb6a2dd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mask of the signals allowed to be sent to <code><a class="el" href="#ae208ec30e868b98262cf15e4f4f88f9e">my_pid</a></code>. <br /></td></tr>
<tr class="separator:aa241be73ffbea4de2071fd4eb6a2dd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d2cefaf8097b3f9b8a363d261da3bd" id="r_ac9d2cefaf8097b3f9b8a363d261da3bd"><td class="memItemLeft" align="right" valign="top"><a id="ac9d2cefaf8097b3f9b8a363d261da3bd" name="ac9d2cefaf8097b3f9b8a363d261da3bd"></a>
u64&#160;</td><td class="memItemRight" valign="bottom"><b>bpf_dev_id</b></td></tr>
<tr class="memdesc:ac9d2cefaf8097b3f9b8a363d261da3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device id of the /sys/bpf mount point inode. <br /></td></tr>
<tr class="separator:ac9d2cefaf8097b3f9b8a363d261da3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccd1c4eb376a6a5f6401d616a68bd50" id="r_aeccd1c4eb376a6a5f6401d616a68bd50"><td class="memItemLeft" align="right" valign="top"><a id="aeccd1c4eb376a6a5f6401d616a68bd50" name="aeccd1c4eb376a6a5f6401d616a68bd50"></a>
u64&#160;</td><td class="memItemRight" valign="bottom"><b>sys_dev_id</b></td></tr>
<tr class="memdesc:aeccd1c4eb376a6a5f6401d616a68bd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device id of the /sys mount point inode. <br /></td></tr>
<tr class="separator:aeccd1c4eb376a6a5f6401d616a68bd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb760c538cb75e9aaa2b412afe58ce9" id="r_a1cb760c538cb75e9aaa2b412afe58ce9"><td class="memItemLeft" align="right" valign="top"><a id="a1cb760c538cb75e9aaa2b412afe58ce9" name="a1cb760c538cb75e9aaa2b412afe58ce9"></a>
u8&#160;</td><td class="memItemRight" valign="bottom"><b>my_binary_path</b> [<a class="el" href="constants_8h.html#ae688d728e1acdfe5988c7db45d6f0166">PATH_MAX</a>]</td></tr>
<tr class="memdesc:a1cb760c538cb75e9aaa2b412afe58ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The path of the seabee binary. u8 plays nicer with rust. <br /></td></tr>
<tr class="separator:a1cb760c538cb75e9aaa2b412afe58ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eca4835f7fc2823d9a0826997a38f22" id="r_a8eca4835f7fc2823d9a0826997a38f22"><td class="memItemLeft" align="right" valign="top"><a id="a8eca4835f7fc2823d9a0826997a38f22" name="a8eca4835f7fc2823d9a0826997a38f22"></a>
u8&#160;</td><td class="memItemRight" valign="bottom"><b>null_path</b> [<a class="el" href="constants_8h.html#ae688d728e1acdfe5988c7db45d6f0166">PATH_MAX</a>]</td></tr>
<tr class="memdesc:a8eca4835f7fc2823d9a0826997a38f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to null a buffer <br /></td></tr>
<tr class="separator:a8eca4835f7fc2823d9a0826997a38f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47d839b2119d334db696f6d365fc90f" id="r_aa47d839b2119d334db696f6d365fc90f"><td class="memItemLeft" align="right" valign="top">struct log_ringbuf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa47d839b2119d334db696f6d365fc90f">log_ringbuf</a></td></tr>
<tr class="memdesc:aa47d839b2119d334db696f6d365fc90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">eBPF Maps  <br /></td></tr>
<tr class="separator:aa47d839b2119d334db696f6d365fc90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf9bb9f0374c3d689bdbbf1fa50bef2" id="r_adaf9bb9f0374c3d689bdbbf1fa50bef2"><td class="memItemLeft" align="right" valign="top"><a id="adaf9bb9f0374c3d689bdbbf1fa50bef2" name="adaf9bb9f0374c3d689bdbbf1fa50bef2"></a>
struct inode_storage&#160;</td><td class="memItemRight" valign="bottom"><b>inode_storage</b></td></tr>
<tr class="memdesc:adaf9bb9f0374c3d689bdbbf1fa50bef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps and inode to a policy id <br /></td></tr>
<tr class="separator:adaf9bb9f0374c3d689bdbbf1fa50bef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0556a1da33555a2a9b767da533a674" id="r_aec0556a1da33555a2a9b767da533a674"><td class="memItemLeft" align="right" valign="top"><a id="aec0556a1da33555a2a9b767da533a674" name="aec0556a1da33555a2a9b767da533a674"></a>
struct policy_map&#160;</td><td class="memItemRight" valign="bottom"><b>policy_map</b></td></tr>
<tr class="memdesc:aec0556a1da33555a2a9b767da533a674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashmap from policy id to policy config. <br /></td></tr>
<tr class="separator:aec0556a1da33555a2a9b767da533a674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4848f79808fd9d1ccaa5cfecca26f64" id="r_aa4848f79808fd9d1ccaa5cfecca26f64"><td class="memItemLeft" align="right" valign="top">struct task_storage&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4848f79808fd9d1ccaa5cfecca26f64">task_storage</a></td></tr>
<tr class="memdesc:aa4848f79808fd9d1ccaa5cfecca26f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps process pid to policy id  <br /></td></tr>
<tr class="separator:aa4848f79808fd9d1ccaa5cfecca26f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7dc065169aed1b6541cc68dd10be4b" id="r_acc7dc065169aed1b6541cc68dd10be4b"><td class="memItemLeft" align="right" valign="top"><a id="acc7dc065169aed1b6541cc68dd10be4b" name="acc7dc065169aed1b6541cc68dd10be4b"></a>
struct sk_storage&#160;</td><td class="memItemRight" valign="bottom"><b>sk_storage</b></td></tr>
<tr class="memdesc:acc7dc065169aed1b6541cc68dd10be4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct sock to policy id <br /></td></tr>
<tr class="separator:acc7dc065169aed1b6541cc68dd10be4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da566d32339313171e0f49c17d96ee2" id="r_a6da566d32339313171e0f49c17d96ee2"><td class="memItemLeft" align="right" valign="top"><a id="a6da566d32339313171e0f49c17d96ee2" name="a6da566d32339313171e0f49c17d96ee2"></a>
struct map_to_pol_id&#160;</td><td class="memItemRight" valign="bottom"><b>map_to_pol_id</b></td></tr>
<tr class="memdesc:a6da566d32339313171e0f49c17d96ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps a map id to a policy id <br /></td></tr>
<tr class="separator:a6da566d32339313171e0f49c17d96ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7327035a79233143a9901d4f0f6262e2" id="r_a7327035a79233143a9901d4f0f6262e2"><td class="memItemLeft" align="right" valign="top"><a id="a7327035a79233143a9901d4f0f6262e2" name="a7327035a79233143a9901d4f0f6262e2"></a>
struct path_to_pol_id&#160;</td><td class="memItemRight" valign="bottom"><b>path_to_pol_id</b></td></tr>
<tr class="memdesc:a7327035a79233143a9901d4f0f6262e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a filename to a policy id. <br /></td></tr>
<tr class="separator:a7327035a79233143a9901d4f0f6262e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443b441d347ce06759c65955d04ecf2d" id="r_a443b441d347ce06759c65955d04ecf2d"><td class="memItemLeft" align="right" valign="top"><a id="a443b441d347ce06759c65955d04ecf2d" name="a443b441d347ce06759c65955d04ecf2d"></a>
struct path_storage&#160;</td><td class="memItemRight" valign="bottom"><b>path_storage</b></td></tr>
<tr class="memdesc:a443b441d347ce06759c65955d04ecf2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">storage for paths <br /></td></tr>
<tr class="separator:a443b441d347ce06759c65955d04ecf2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a29a8315efd07a8542742e0c0cc389e0a" name="a29a8315efd07a8542742e0c0cc389e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a8315efd07a8542742e0c0cc389e0a">&#9670;&#160;</a></span>seabee_bpf_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_bpf_map </td>
          <td>(</td>
          <td class="paramtype">struct bpf_map *</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fmode_t</td>          <td class="paramname"><span class="paramname"><em>fmode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ret</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks manipulation a protected map. </p>
<p>This is achieved by preventing BPF file descriptors from being created for protected maps.</p>
<p>A file descriptor for a map can be obtained via the commands:</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>internal BPF map structure </td></tr>
    <tr><td class="paramname">fmode</td><td>file mode to open with (read / write / etc) </td></tr>
    <tr><td class="paramname">ret</td><td>return code from previous LSM hook</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code> </dd></dl>

</div>
</div>
<a id="a17afaf237b1083b2eb37cb8607c6bb3f" name="a17afaf237b1083b2eb37cb8607c6bb3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17afaf237b1083b2eb37cb8607c6bb3f">&#9670;&#160;</a></span>seabee_file_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_file_open </td>
          <td>(</td>
          <td class="paramtype">struct file *</td>          <td class="paramname"><span class="paramname"><em>file</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make protected files read-only. </p>
<p>This hook is called to check if a file is allowed to be accessed. Deny access to protected files by checking file-&gt;f_mode. This tells if the file is being opened for reading or writing. </p>

</div>
</div>
<a id="a7949bcbdd6820449daf5836350c9695e" name="a7949bcbdd6820449daf5836350c9695e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7949bcbdd6820449daf5836350c9695e">&#9670;&#160;</a></span>seabee_inode_unlink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_inode_unlink </td>
          <td>(</td>
          <td class="paramtype">struct inode *</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct dentry *</td>          <td class="paramname"><span class="paramname"><em>dentry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ret</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevents unlinking/removing the protected pins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>the parent directory </td></tr>
    <tr><td class="paramname">dentry</td><td>the file being unlinked </td></tr>
    <tr><td class="paramname">ret</td><td>the return code of the previous LSM hook</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code> </dd></dl>

</div>
</div>
<a id="a256b85baf8c830a5ed40975c94943bdd" name="a256b85baf8c830a5ed40975c94943bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256b85baf8c830a5ed40975c94943bdd">&#9670;&#160;</a></span>seabee_kernel_load_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_kernel_load_data </td>
          <td>(</td>
          <td class="paramtype">enum kernel_load_data_id</td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>contents</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the loading of a kernel module via a data blob. </p>
<p>lsm/kernel_load_data is invoked when userspace tries to load a data blob from its memory into the kernel, including but not limited to kernel modules loaded via init_module().</p>
<p>enum kernel_load_data_id is the same as __kernel_read_file_id defined in <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/kernel_read_file.h#L9">https://elixir.bootlin.com/linux/latest/source/include/linux/kernel_read_file.h#L9</a> It has several types including unknown, firmware, module, kexec-image, kexec-initramfs, security-policy, and x509-certificate. kernel-module seems most appropriate for our purposes, but the others should be taken into account later on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>defines what kind of data is being read. </td></tr>
    <tr><td class="paramname">contents</td><td>true if security_kernel_post_load_data() will be called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code> </dd></dl>

</div>
</div>
<a id="afe4c0b3cece29f53f28020c11e5310fc" name="afe4c0b3cece29f53f28020c11e5310fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4c0b3cece29f53f28020c11e5310fc">&#9670;&#160;</a></span>seabee_kernel_module_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_kernel_module_request </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>kmod_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevent a kernel module from being automatically loaded by the kernel. </p>
<p>lsm/kernel_module_request is invoked when module auto-loading is triggered by some attempt to access kernel functionality implemented by a module. It is used internally by the kernel to check if loading a module is allowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kmod_name</td><td>the name of ther kernel module to be loaded</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code> </dd></dl>

</div>
</div>
<a id="a485e0bd9e20eae669ea092248bf26ecf" name="a485e0bd9e20eae669ea092248bf26ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485e0bd9e20eae669ea092248bf26ecf">&#9670;&#160;</a></span>seabee_kernel_read_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_kernel_read_file </td>
          <td>(</td>
          <td class="paramtype">struct file *</td>          <td class="paramname"><span class="paramname"><em>file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum kernel_read_file_id</td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>contents</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the loading of a kernel module via a file handle. </p>
<p>lsm/kernel_read_file is invoked when the kernel is about to directly read from a file or the file system specified by userspace for some purpose including but not limited to kernel modules laoded via finit_module()</p>
<p>enum kernel_load_data_id is the same as __kernel_read_file_id defined in <a href="https://elixir.bootlin.com/linux/latest/source/include/linux/kernel_read_file.h#L9">https://elixir.bootlin.com/linux/latest/source/include/linux/kernel_read_file.h#L9</a> It has several types including unknown, firmware, module, kexec-image, kexec-initramfs, security-policy, and x509-certificate. kernel-module seems most appropriate for our purposes, but the others should be taken into account later on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the file from which to read </td></tr>
    <tr><td class="paramname">id</td><td>identifies the type of data that is being read </td></tr>
    <tr><td class="paramname">contents</td><td>true if security_post_read_file() will be called</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code> </dd></dl>

</div>
</div>
<a id="a9230263f1e385048936352e3412647bf" name="a9230263f1e385048936352e3412647bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9230263f1e385048936352e3412647bf">&#9670;&#160;</a></span>seabee_label_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_label_process </td>
          <td>(</td>
          <td class="paramtype">struct linux_binprm *</td>          <td class="paramname"><span class="paramname"><em>bprm</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ret</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Label a process when it starts. </p>
<p>This uses the <a class="el" href="structpath__to__pol__id.html">path_to_pol_id</a> map and the linux_binprm structure to attach a label to a task based on the path of the executable that started the task. This hook can be called multiple times during an execve, for example, if executing a script.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bprm</td><td>holds information about a binary that is going to be executed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> since this check is just for labeling and not for enforcement </dd></dl>

</div>
</div>
<a id="a85b867df13b7a473049f1a0f3b7a2033" name="a85b867df13b7a473049f1a0f3b7a2033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b867df13b7a473049f1a0f3b7a2033">&#9670;&#160;</a></span>seabee_label_sock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_label_sock </td>
          <td>(</td>
          <td class="paramtype">struct socket *</td>          <td class="paramname"><span class="paramname"><em>sock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *</td>          <td class="paramname"><span class="paramname"><em>address</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>addrlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>used to label a socket on creation. </p>
<p>This will only label sockets created by the SeaBee userspace. Specifically this is used to control access to SeaBee's listening socket to ensure only seabeectl can connect to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>the socket being bound </td></tr>
    <tr><td class="paramname">address</td><td>requested bind address </td></tr>
    <tr><td class="paramname">addrlen</td><td>length of address</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> to allow access </dd></dl>

</div>
</div>
<a id="a5e0513d1676e6013f62974623e1523da" name="a5e0513d1676e6013f62974623e1523da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e0513d1676e6013f62974623e1523da">&#9670;&#160;</a></span>seabee_locked_down()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_locked_down </td>
          <td>(</td>
          <td class="paramtype">enum lockdown_reason</td>          <td class="paramname"><span class="paramname"><em>what</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks the use of the bpf_write_user() helper. </p>
<p>This helper function is dangerous and it is better to disable it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">what</td><td>why the lockdown hook is firing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code>man 7 kernel_lockdown</code> </dd></dl>

</div>
</div>
<a id="ad28ea14e7ad0112bd28ca673105daf7e" name="ad28ea14e7ad0112bd28ca673105daf7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28ea14e7ad0112bd28ca673105daf7e">&#9670;&#160;</a></span>seabee_ptrace_access_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_ptrace_access_check </td>
          <td>(</td>
          <td class="paramtype">struct task_struct *</td>          <td class="paramname"><span class="paramname"><em>child</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>mode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ret</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks attempts to trace the seabee userspace process. </p>
<p>This hook is not loaded if ptrace protections are disabled.</p>
<p>note: there is also an lsm/ptrace_traceme hook. This hook is not checked because it is only invoked by the child process. Since our process will not ask to be ptraced. We do not need to implement that hook. If our process is exec'd by a process that is being ptraced already, we believe we have already lost all security.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>the process that is going to be traced </td></tr>
    <tr><td class="paramname">mode</td><td>PTRACE_MODE flags </td></tr>
    <tr><td class="paramname">ret</td><td>the return code of the previous LSM hook</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code> </dd></dl>

</div>
</div>
<a id="a81b9df20c0568dc8c64f602f63e14856" name="a81b9df20c0568dc8c64f602f63e14856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b9df20c0568dc8c64f602f63e14856">&#9670;&#160;</a></span>seabee_sb_umount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_sb_umount </td>
          <td>(</td>
          <td class="paramtype">struct vfsmount *</td>          <td class="paramname"><span class="paramname"><em>mnt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ret</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prevent unmounting the BPF filesystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mnt</td><td>mounted filesystem </td></tr>
    <tr><td class="paramname">flags</td><td>unmount flags </td></tr>
    <tr><td class="paramname">ret</td><td>the return code of the previous LSM hook</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code> </dd></dl>

</div>
</div>
<a id="a896edf055e965814fe057c78e6206c59" name="a896edf055e965814fe057c78e6206c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896edf055e965814fe057c78e6206c59">&#9670;&#160;</a></span>seabee_task_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_task_alloc </td>
          <td>(</td>
          <td class="paramtype">struct task_struct *</td>          <td class="paramname"><span class="paramname"><em>task</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>clone_flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ret</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks attempts to fork() the seabee process. </p>
<p>A fork() / clone() of the seabee process will inherit all of the memory and file-descriptors of the parent process. This would allow the child process to unload the BPF program or alter the map contents. This is more of a safety-net than anything.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the process that is going to be forked </td></tr>
    <tr><td class="paramname">clone_flags</td><td>flags from struct kernel_clone_args </td></tr>
    <tr><td class="paramname">ret</td><td>the return code of the previous LSM hook</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code> </dd></dl>

</div>
</div>
<a id="ae0493f708b0f0ddf94b055afa38347f9" name="ae0493f708b0f0ddf94b055afa38347f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0493f708b0f0ddf94b055afa38347f9">&#9670;&#160;</a></span>seabee_task_kill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabee_task_kill </td>
          <td>(</td>
          <td class="paramtype">struct task_struct *</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct kernel_siginfo *</td>          <td class="paramname"><span class="paramname"><em>info</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sig</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct cred *</td>          <td class="paramname"><span class="paramname"><em>cred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ret</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block unwanted signals to the seabee userspace process. </p>
<p>Deny any outside userspace signal that will stop our corresponding userspace process almost every signal will kill our process, we choose to enumerate (and allow) those which do not stop our process. Signals that originate from the kernel may not be caught because they may use a different code path that does not include this lsm hook. These signals include the <code><a class="el" href="seabee__utils_8h.html#ac328e551bde3d39b6d7b8cc9e048d941">ZERO</a></code> signal and any signal specified in the <code><a class="el" href="#aa241be73ffbea4de2071fd4eb6a2dd06">sigmask</a></code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>target process </td></tr>
    <tr><td class="paramname">info</td><td>signal info, can also be NULL or 1 </td></tr>
    <tr><td class="paramname">sig</td><td>signal value </td></tr>
    <tr><td class="paramname">cred</td><td>credentials of sender, may be NULL </td></tr>
    <tr><td class="paramname">ret</td><td>the return code of the previous LSM hook</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> or <code><a class="el" href="seabee__utils_8h.html#a7d47603ec531f399d75396e75bd14667">DENY</a></code></dd></dl>
<dl class="section see"><dt>See also</dt><dd>signal numbering and default actions: <code>man signal</code> </dd></dl>

</div>
</div>
<a id="a7862e20a4d187c60d970fdf02fd84c55" name="a7862e20a4d187c60d970fdf02fd84c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7862e20a4d187c60d970fdf02fd84c55">&#9670;&#160;</a></span>seabeectl_auth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int seabeectl_auth </td>
          <td>(</td>
          <td class="paramtype">struct sock *</td>          <td class="paramname"><span class="paramname"><em>sock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sock *</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sock *</td>          <td class="paramname"><span class="paramname"><em>newsk</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if a process is allowed to connect to a socket. </p>
<p>This is used to enforce that only seabeectl is allowed to connect to the listening socket of SeaBee in order to receive commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>originating sock </td></tr>
    <tr><td class="paramname">other</td><td>peer sock </td></tr>
    <tr><td class="paramname">newsk</td><td>new sock</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="seabee__utils_8h.html#a983112bf58b39715a5d1142ebc4284dc">ALLOW</a></code> to allow access </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a9e5b3870f32ed99cf58fe41b09d15181" name="a9e5b3870f32ed99cf58fe41b09d15181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5b3870f32ed99cf58fe41b09d15181">&#9670;&#160;</a></span>log_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 log_level</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The level of the logs to filter out. </p>
<p>Defined in each .bpf.c file. Specifies which logs to output to the ringbuf. </p>

</div>
</div>
<a id="aa47d839b2119d334db696f6d365fc90f" name="aa47d839b2119d334db696f6d365fc90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47d839b2119d334db696f6d365fc90f">&#9670;&#160;</a></span>log_ringbuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct log_ringbuf log_ringbuf</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>eBPF Maps </p>
<p>Defined in each .bpf.c file. Specifies the ringbuf map to output logs to.</p>
<p>logs data back to userspace </p>

</div>
</div>
<a id="aa4848f79808fd9d1ccaa5cfecca26f64" name="aa4848f79808fd9d1ccaa5cfecca26f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4848f79808fd9d1ccaa5cfecca26f64">&#9670;&#160;</a></span>task_storage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct task_storage task_storage</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>maps process pid to policy id </p>
<p>local storage for tasks </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
